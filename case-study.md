# Case-study оптимизации

## Актуальная проблема
В нашем проекте возникла серьёзная проблема.

Необходимо было обработать файл с данными, чуть больше ста мегабайт.

У нас уже была программа на `ruby`, которая умела делать нужную обработку.

Она успешно работала на файлах размером пару мегабайт, но для большого файла она требует слишком большого объема памяти.

Была поставлена задача, чтобы за все время обработки рабочего файла программа не занимала более 70 мегабайт оперативной памяти.

# Анализ задачи

Исходный файл имеет размер 130 мегабайт, что уже больше бюджета, а значит чтение и анализ файла надо проводить построчно.
  
## Формирование метрики
Для анализа влияния изменений кода на занимаемую память будем размер замаемой памяти в конце задачи, когда использование памяти максимально. 

В начала работы использую такую метрику - обработка 20 000 строк занимает 82 Мб памяти.

## Гарантия корректности работы оптимизированной программы
Программа поставлялась с тестом. Выполнение этого теста в фидбек-лупе позволяет не допустить изменения логики программы при оптимизации.


## Feedback-Loop
Для того, чтобы иметь возможность быстро проверять гипотезы я выстроил эффективный `feedback-loop`, который позволил мне получать обратную связь по эффективности сделанных изменений за 10-20 секунд

Для получения обратной связи я пользуюсь командой которая проверяет корректность работы, потом замеряет
метрику.

ruby task-2.rb && ruby work.rb data20000.txt 

После чего я запускаю профайлер и по его отчету анализирую изменения
 
## Вникаем в детали системы, чтобы найти главные точки роста
Для того, чтобы найти "точки роста" для оптимизации я воспользовался
- гемом memory_profiler

Вот какие проблемы удалось найти и решить

### Находка №1
- memory_profiler показал, что самую большую часть памяти среди объектов занимают массивы 1.65 GB 
- решено отказаться от сбора данных в массивы, а обрабатывать и записывать отчет по каждому пользователю
- метрика уменьшилась до 15 мегабайт
- как изменился отчёт профилировщика теперь массивы занимают 13.36 MB

### Изменение метрики
 Замеряю использованную память при обработке 200_000 строк - 15 MB
 Замеряю использованную память при обработке 1_500_000 строк - 17 MB
 Замеряю использованную память при обработке всего рабочего файла - 17 MB
 
## Результаты
В результате проделанной оптимизации удалось обработать файл с данными.
Грубое измерение метрики показывает, что программа укладывается в бюджет.




Удалось улучшить метрику системы с *того, что у вас было в начале, до того, что получилось в конце* и уложиться в заданный бюджет.

*Какими ещё результами можете поделиться*

## Защита от регрессии производительности
Для защиты от потери достигнутого прогресса при дальнейших изменениях программы *о performance-тестах, которые вы написали*

## Checklist
- [+] Построить и проанализировать отчёт гемом `memory_profiler`
- [+] Построить и проанализировать отчёт `ruby-prof` в режиме `Flat`;
**не нагляден**

- [+] Построить и проанализировать отчёт `ruby-prof` в режиме `Graph`;
**удобен, но надо разносить код в именованые методы**

- [+] Построить и проанализировать отчёт `ruby-prof` в режиме `CallStack`;
**очень удобное представление, но надо разносить код в именованые методы**

- [+] Построить и проанализировать отчёт `ruby-prof` в режиме `CallTree` c визуализацией в `QCachegrind`;
**В убунту не нашел QCachegrind, есть kcachegrind, там нет отображения в виде блок-схемы**

- [+] Построить и проанализировать текстовый отчёт `stackprof` для рабочего файла
```
 stackprof stackprof_reports/stackprof.dump                       
  ==================================
    Mode: object(1)
    Samples: 32641643 (0.00% miss rate)
    GC: 0 (0.00%)
  ==================================
       TOTAL    (pct)     SAMPLES    (pct)     FRAME
    32641641 (100.0%)    23538567  (72.1%)     Object#work
     9103074  (27.9%)     9103074  (27.9%)     Object#report_user
    32641643 (100.0%)           2   (0.0%)     block in <main>
    32641643 (100.0%)           0   (0.0%)     <main>
    32641643 (100.0%)           0   (0.0%)     <main>
```
 **получить данные по методам не удалось**

- [ ] Построить и проанализировать отчёт `flamegraph` с помощью `stackprof` и визуализировать его в `speedscope.app`;
- [ ] Построить график потребления памяти в `valgrind massif visualier` и включить скриншот в описание вашего `PR`;